{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u00b6 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"asyncio/","text":"ASYNCIO \u00b6 Awaitables \u00b6 import asyncio import logging logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def do_work ( delay , work ): await asyncio . sleep ( delay ) log . info ( work ) async def main (): log . info ( \"start\" ) await do_work ( 1 , \"hello\" ) await do_work ( 2 , \"world\" ) log . info ( \"end should take 3 sec\" ) asyncio . run ( main ()) Coroutines \u00b6 function that can be awaitable - coroutine function : define as async function async def f() the call to async function return coroutine object - awaitable : anything that works with await : coroutine, Tasks, Futures - coroutine object : return by coroutine function import asyncio import logging logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def do_work ( delay , work ): await asyncio . sleep ( delay ) log . info ( work ) async def main (): co = do_work ( 1 , \"hello coroutine\" ) log . info ( type ( co )) await co asyncio . run ( main ()) Result \u00b6 [INFO] 2021-12-21 05:56:33,703 <class 'coroutine'> [INFO] 2021-12-21 05:56:34,704 hello coroutine Task \u00b6 Tasks wrap coroutine and used to scheduler coroutines concurrently import asyncio import logging logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def do_work ( delay , work ): await asyncio . sleep ( delay ) log . info ( work ) async def main (): log . info ( \"start\" ) t1 = asyncio . create_task ( do_work ( 1 , \"hello\" )) t2 = asyncio . create_task ( do_work ( 2 , \"world\" )) await t1 await t2 log . info ( \"end should take 2 sec\" ) asyncio . run ( main ()) Waiting \u00b6 wait \u00b6 Wait method take list of tasks as iterable and return tow sets: - list of done/finished tasks - list of pending/unfinished tasks done , pending = await asyncio . wait ([ task_f , task_g ]) Wait for first task to finish it's work \u00b6 file not found / home / user / projects / python_cookbook / asyncio_cook / wait . py wait with timeout \u00b6 file not found / home / user / projects / python_cookbook / asyncio_cook / wait_with_timeout . py wait_for \u00b6 file not found / home / user / projects / python_cookbook / asyncio_cook / wait_for_demo . py References \u00b6 Python reference A Hitchhikers Guide to Asynchronous Programming Python asyncio Guide to Concurrency in Python with Asyncio","title":"ASYNCIO"},{"location":"asyncio/#asyncio","text":"","title":"ASYNCIO"},{"location":"asyncio/#awaitables","text":"import asyncio import logging logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def do_work ( delay , work ): await asyncio . sleep ( delay ) log . info ( work ) async def main (): log . info ( \"start\" ) await do_work ( 1 , \"hello\" ) await do_work ( 2 , \"world\" ) log . info ( \"end should take 3 sec\" ) asyncio . run ( main ())","title":"Awaitables"},{"location":"asyncio/#coroutines","text":"function that can be awaitable - coroutine function : define as async function async def f() the call to async function return coroutine object - awaitable : anything that works with await : coroutine, Tasks, Futures - coroutine object : return by coroutine function import asyncio import logging logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def do_work ( delay , work ): await asyncio . sleep ( delay ) log . info ( work ) async def main (): co = do_work ( 1 , \"hello coroutine\" ) log . info ( type ( co )) await co asyncio . run ( main ())","title":"Coroutines"},{"location":"asyncio/#result","text":"[INFO] 2021-12-21 05:56:33,703 <class 'coroutine'> [INFO] 2021-12-21 05:56:34,704 hello coroutine","title":"Result"},{"location":"asyncio/#task","text":"Tasks wrap coroutine and used to scheduler coroutines concurrently import asyncio import logging logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def do_work ( delay , work ): await asyncio . sleep ( delay ) log . info ( work ) async def main (): log . info ( \"start\" ) t1 = asyncio . create_task ( do_work ( 1 , \"hello\" )) t2 = asyncio . create_task ( do_work ( 2 , \"world\" )) await t1 await t2 log . info ( \"end should take 2 sec\" ) asyncio . run ( main ())","title":"Task"},{"location":"asyncio/#waiting","text":"","title":"Waiting"},{"location":"asyncio/#wait","text":"Wait method take list of tasks as iterable and return tow sets: - list of done/finished tasks - list of pending/unfinished tasks done , pending = await asyncio . wait ([ task_f , task_g ])","title":"wait"},{"location":"asyncio/#wait-for-first-task-to-finish-its-work","text":"file not found / home / user / projects / python_cookbook / asyncio_cook / wait . py","title":"Wait for first task to finish it's work"},{"location":"asyncio/#wait-with-timeout","text":"file not found / home / user / projects / python_cookbook / asyncio_cook / wait_with_timeout . py","title":"wait with timeout"},{"location":"asyncio/#wait_for","text":"file not found / home / user / projects / python_cookbook / asyncio_cook / wait_for_demo . py","title":"wait_for"},{"location":"asyncio/#references","text":"Python reference A Hitchhikers Guide to Asynchronous Programming Python asyncio Guide to Concurrency in Python with Asyncio","title":"References"},{"location":"asyncio/execute/","text":"Call Task from other thread \u00b6 Scheduler Task from other thread task_from_thread.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import asyncio import logging import threading logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) def handler ( future : asyncio . Future ): log . info ( future . result ()) def executer ( loop ): co = asyncio . run_coroutine_threadsafe ( hello ( \"thread\" ), loop ) co . add_done_callback ( handler ) async def hello ( msg ): log . info ( f \"start from { msg } \" ) await asyncio . sleep ( 1 ) return f \"done { msg } \" loop = asyncio . get_event_loop () worker = threading . Thread ( target = executer , args = ( loop ,), daemon = True ) worker . start () t1 = loop . create_task ( hello ( \"event loop\" )) t1 . add_done_callback ( handler ) loop . run_forever () Result [INFO] 2022-01-08 21:04:30,885 start from event loop [INFO] 2022-01-08 21:04:30,885 start from thread [INFO] 2022-01-08 21:04:31,886 done event loop [INFO] 2022-01-08 21:04:31,887 done thread Schedule \u00b6 schedule_fom_thread.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import asyncio import logging import threading import time from functools import partial logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) def foo ( method ): log . info ( f \"running foo using { method } \" ) def executer ( loop : asyncio . BaseEventLoop ): time . sleep ( 1 ) loop . call_soon_threadsafe ( foo , \"direct\" ) func = partial ( foo , \"partial\" ) loop . call_soon_threadsafe ( func ) loop = asyncio . get_event_loop () worker = threading . Thread ( target = executer , args = ( loop ,), daemon = True ) worker . start () loop . run_forever () Executer \u00b6 executer.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import asyncio import concurrent.futures import logging logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) def blocking_io (): # File operations (such as logging) can block the # event loop: run them in a thread pool. with open ( \"/dev/urandom\" , \"rb\" ) as f : return f . read ( 100 ) def cpu_bound (): # CPU-bound operations will block the event loop: # in general it is preferable to run them in a # process pool. return sum ( i * i for i in range ( 10 ** 7 )) async def main (): loop = asyncio . get_running_loop () # 1. Run in the default loop's executor: result = await loop . run_in_executor ( None , blocking_io ) log . info ( f \"default thread pool: { result } \" ) # 2. Run in a custom thread pool: with concurrent . futures . ThreadPoolExecutor () as pool : result = await loop . run_in_executor ( pool , blocking_io ) log . info ( f \"custom thread pool: { result } \" ) # 3. Run in a custom process pool: with concurrent . futures . ProcessPoolExecutor () as pool : result = await loop . run_in_executor ( pool , cpu_bound ) log . info ( f \"custom process pool: { result } \" ) asyncio . run ( main ())","title":"Execute"},{"location":"asyncio/execute/#call-task-from-other-thread","text":"Scheduler Task from other thread task_from_thread.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import asyncio import logging import threading logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) def handler ( future : asyncio . Future ): log . info ( future . result ()) def executer ( loop ): co = asyncio . run_coroutine_threadsafe ( hello ( \"thread\" ), loop ) co . add_done_callback ( handler ) async def hello ( msg ): log . info ( f \"start from { msg } \" ) await asyncio . sleep ( 1 ) return f \"done { msg } \" loop = asyncio . get_event_loop () worker = threading . Thread ( target = executer , args = ( loop ,), daemon = True ) worker . start () t1 = loop . create_task ( hello ( \"event loop\" )) t1 . add_done_callback ( handler ) loop . run_forever () Result [INFO] 2022-01-08 21:04:30,885 start from event loop [INFO] 2022-01-08 21:04:30,885 start from thread [INFO] 2022-01-08 21:04:31,886 done event loop [INFO] 2022-01-08 21:04:31,887 done thread","title":"Call Task from other thread"},{"location":"asyncio/execute/#schedule","text":"schedule_fom_thread.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import asyncio import logging import threading import time from functools import partial logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) def foo ( method ): log . info ( f \"running foo using { method } \" ) def executer ( loop : asyncio . BaseEventLoop ): time . sleep ( 1 ) loop . call_soon_threadsafe ( foo , \"direct\" ) func = partial ( foo , \"partial\" ) loop . call_soon_threadsafe ( func ) loop = asyncio . get_event_loop () worker = threading . Thread ( target = executer , args = ( loop ,), daemon = True ) worker . start () loop . run_forever ()","title":"Schedule"},{"location":"asyncio/execute/#executer","text":"executer.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import asyncio import concurrent.futures import logging logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) def blocking_io (): # File operations (such as logging) can block the # event loop: run them in a thread pool. with open ( \"/dev/urandom\" , \"rb\" ) as f : return f . read ( 100 ) def cpu_bound (): # CPU-bound operations will block the event loop: # in general it is preferable to run them in a # process pool. return sum ( i * i for i in range ( 10 ** 7 )) async def main (): loop = asyncio . get_running_loop () # 1. Run in the default loop's executor: result = await loop . run_in_executor ( None , blocking_io ) log . info ( f \"default thread pool: { result } \" ) # 2. Run in a custom thread pool: with concurrent . futures . ThreadPoolExecutor () as pool : result = await loop . run_in_executor ( pool , blocking_io ) log . info ( f \"custom thread pool: { result } \" ) # 3. Run in a custom process pool: with concurrent . futures . ProcessPoolExecutor () as pool : result = await loop . run_in_executor ( pool , cpu_bound ) log . info ( f \"custom process pool: { result } \" ) asyncio . run ( main ())","title":"Executer"},{"location":"asyncio/sync_tasks/","text":"Using lock Using Event Calling Tasks \u00b6 simple_tasks.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import asyncio import logging logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def hello ( msg ): log . info ( f \"start { msg } \" ) await asyncio . sleep ( 1 ) log . info ( f \"end { msg } \" ) loop = asyncio . get_event_loop () t1 = loop . create_task ( hello ( \"hello1\" )) t2 = loop . create_task ( hello ( \"hello2\" )) group = asyncio . gather ( t1 , t2 ) loop . run_until_complete ( group ) Result [INFO] 2022-01-08 15:49:20,719 start hello1 [INFO] 2022-01-08 15:49:20,719 start hello2 [INFO] 2022-01-08 15:49:21,720 end hello1 [INFO] 2022-01-08 15:49:21,720 end hello2 Sync Tasks \u00b6 using asyncio.lock sync_tasks.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import asyncio import logging logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) lock_ = asyncio . Lock () async def hello ( msg ): async with lock_ : log . info ( f \"start { msg } \" ) await asyncio . sleep ( 1 ) log . info ( f \"end { msg } \" ) loop = asyncio . get_event_loop () t1 = loop . create_task ( hello ( \"hello1\" )) t2 = loop . create_task ( hello ( \"hello2\" )) group = asyncio . gather ( t1 , t2 ) loop . run_until_complete ( group ) Result [INFO] 2022-01-08 18:31:06,517 start hello1 [INFO] 2022-01-08 18:31:07,518 end hello1 [INFO] 2022-01-08 18:31:07,518 start hello2 [INFO] 2022-01-08 18:31:08,520 end hello2 Events \u00b6 Event signal between tasks \u00b6 signal_between_tasks.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import asyncio import logging from asyncio import Event logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def worker ( e : Event ): log . info ( \"start worker\" ) await asyncio . sleep ( 1 ) log . info ( \"end worker\" ) e . set () async def waiter ( e : Event ): await e . wait () log . info ( \"start waiter\" ) await asyncio . sleep ( 1 ) log . info ( \"end waiter\" ) loop = asyncio . get_event_loop () e = Event () t1 = loop . create_task ( worker ( e )) t2 = loop . create_task ( waiter ( e )) group = asyncio . gather ( t1 , t2 ) loop . run_until_complete ( group )","title":"Sync tasks"},{"location":"asyncio/sync_tasks/#calling-tasks","text":"simple_tasks.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import asyncio import logging logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def hello ( msg ): log . info ( f \"start { msg } \" ) await asyncio . sleep ( 1 ) log . info ( f \"end { msg } \" ) loop = asyncio . get_event_loop () t1 = loop . create_task ( hello ( \"hello1\" )) t2 = loop . create_task ( hello ( \"hello2\" )) group = asyncio . gather ( t1 , t2 ) loop . run_until_complete ( group ) Result [INFO] 2022-01-08 15:49:20,719 start hello1 [INFO] 2022-01-08 15:49:20,719 start hello2 [INFO] 2022-01-08 15:49:21,720 end hello1 [INFO] 2022-01-08 15:49:21,720 end hello2","title":"Calling Tasks"},{"location":"asyncio/sync_tasks/#sync-tasks","text":"using asyncio.lock sync_tasks.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import asyncio import logging logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) lock_ = asyncio . Lock () async def hello ( msg ): async with lock_ : log . info ( f \"start { msg } \" ) await asyncio . sleep ( 1 ) log . info ( f \"end { msg } \" ) loop = asyncio . get_event_loop () t1 = loop . create_task ( hello ( \"hello1\" )) t2 = loop . create_task ( hello ( \"hello2\" )) group = asyncio . gather ( t1 , t2 ) loop . run_until_complete ( group ) Result [INFO] 2022-01-08 18:31:06,517 start hello1 [INFO] 2022-01-08 18:31:07,518 end hello1 [INFO] 2022-01-08 18:31:07,518 start hello2 [INFO] 2022-01-08 18:31:08,520 end hello2","title":"Sync Tasks"},{"location":"asyncio/sync_tasks/#events","text":"","title":"Events"},{"location":"asyncio/sync_tasks/#event-signal-between-tasks","text":"signal_between_tasks.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import asyncio import logging from asyncio import Event logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def worker ( e : Event ): log . info ( \"start worker\" ) await asyncio . sleep ( 1 ) log . info ( \"end worker\" ) e . set () async def waiter ( e : Event ): await e . wait () log . info ( \"start waiter\" ) await asyncio . sleep ( 1 ) log . info ( \"end waiter\" ) loop = asyncio . get_event_loop () e = Event () t1 = loop . create_task ( worker ( e )) t2 = loop . create_task ( waiter ( e )) group = asyncio . gather ( t1 , t2 ) loop . run_until_complete ( group )","title":"Event signal between tasks"},{"location":"asyncio/wait/","text":"gather \u00b6 Wait for multiple asynchronous tasks to complete import asyncio import logging logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , datefmt = \"%H:%M:%S\" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def foo ( n ): await asyncio . sleep ( n ) log . info ( f \"Run: { n } sec\" ) async def main (): tasks = [ foo ( 1 ), foo ( 2 ), foo ( 3 )] await asyncio . gather ( * tasks ) asyncio . run ( main ()) Result [INFO] 10:04:51 Run: 1 sec [INFO] 10:04:52 Run: 2 sec [INFO] 10:04:53 Run: 3 sec wait \u00b6 python.org Wait for first Task to finished. wait() does not cancel the futures when a timeout occurs. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import asyncio from asyncio.tasks import FIRST_COMPLETED import logging logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , datefmt = \"%H:%M:%S\" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def do_work ( delay , work ): await asyncio . sleep ( delay ) return work async def main (): task1 = asyncio . create_task ( do_work ( 1 , \"hello1\" )) task2 = asyncio . create_task ( do_work ( 2 , \"hello2\" )) task3 = asyncio . create_task ( do_work ( 3 , \"hello3\" )) tasks = { task1 , task2 , task3 } # set finished , unfinished = await asyncio . wait ( tasks , return_when = asyncio . FIRST_COMPLETED ) # Print result from Task that finish running for task in finished : log . info ( task . result ()) # Cancel unfinished for task in unfinished : task . cancel () await asyncio . wait ( unfinished ) asyncio . run ( main ()) wait timeout \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import asyncio import logging logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , datefmt = \"%H:%M:%S\" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def do_work ( delay , work ): await asyncio . sleep ( delay ) return work async def main (): task1 = asyncio . create_task ( do_work ( 1 , \"hello1\" )) task2 = asyncio . create_task ( do_work ( 2 , \"hello2\" )) task3 = asyncio . create_task ( do_work ( 3 , \"hello3\" )) tasks = [ task1 , task2 , task3 ] finished , unfinished = await asyncio . wait ( tasks , timeout = 3 ) for task in finished : log . info ( task . result ()) for task in unfinished : task . cancel () await asyncio . wait ( unfinished ) asyncio . run ( main ()) Result [INFO] 2022-01-08 11:34:43,555 hello2 [INFO] 2022-01-08 11:34:43,555 hello1 wait_for \u00b6 Wait for the awaitable to complete with a timeout. If timeout raise Task are cancelled wait_for_demo.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import asyncio import logging WORK_TIME = 2 logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , datefmt = \"%H:%M:%S\" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def do_work ( delay : int ): log . info ( f \"start work { delay } \" ) await asyncio . sleep ( delay ) log . info ( f \"end work { delay } \" ) async def main (): task = asyncio . create_task ( do_work ( WORK_TIME )) try : await asyncio . wait_for ( asyncio . shield ( task ), timeout = 1 ) log . info ( \"end success\" ) except asyncio . TimeoutError : log . error ( \"oops Timeout\" ) loop = asyncio . get_event_loop () loop . create_task ( main ()) loop . run_forever () Note Task cancel if time out raise To protect task from cancelling use asyncio.shield Replace line 17 with await asyncio.wait_for(asyncio.shield(task), timeout=1) Without shield [INFO] 09:59:20 start work 2 [ERROR] 09:59:21 oops Timeout With shield [INFO] 10:00:05 start work 2 [ERROR] 10:00:06 oops Timeout [INFO] 10:00:07 end work 2 Other examples \u00b6 Run task multiple time with timeout until complete wait_until_success.py import asyncio import logging import random logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , datefmt = \"%H:%M:%S\" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def do_work (): delay = random . randint ( 1 , 4 ) log . info ( f \"start work { delay } \" ) await asyncio . sleep ( delay ) log . info ( f \"end work { delay } \" ) async def main (): while True : try : task = asyncio . create_task ( do_work ()) await asyncio . wait_for ( task , timeout = 2 ) log . info ( \"end success\" ) break except asyncio . TimeoutError : log . error ( \"oops Timeout\" ) loop = asyncio . get_event_loop () loop . create_task ( main ()) loop . run_forever ()","title":"Wait"},{"location":"asyncio/wait/#gather","text":"Wait for multiple asynchronous tasks to complete import asyncio import logging logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , datefmt = \"%H:%M:%S\" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def foo ( n ): await asyncio . sleep ( n ) log . info ( f \"Run: { n } sec\" ) async def main (): tasks = [ foo ( 1 ), foo ( 2 ), foo ( 3 )] await asyncio . gather ( * tasks ) asyncio . run ( main ()) Result [INFO] 10:04:51 Run: 1 sec [INFO] 10:04:52 Run: 2 sec [INFO] 10:04:53 Run: 3 sec","title":"gather"},{"location":"asyncio/wait/#wait","text":"python.org Wait for first Task to finished. wait() does not cancel the futures when a timeout occurs. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import asyncio from asyncio.tasks import FIRST_COMPLETED import logging logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , datefmt = \"%H:%M:%S\" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def do_work ( delay , work ): await asyncio . sleep ( delay ) return work async def main (): task1 = asyncio . create_task ( do_work ( 1 , \"hello1\" )) task2 = asyncio . create_task ( do_work ( 2 , \"hello2\" )) task3 = asyncio . create_task ( do_work ( 3 , \"hello3\" )) tasks = { task1 , task2 , task3 } # set finished , unfinished = await asyncio . wait ( tasks , return_when = asyncio . FIRST_COMPLETED ) # Print result from Task that finish running for task in finished : log . info ( task . result ()) # Cancel unfinished for task in unfinished : task . cancel () await asyncio . wait ( unfinished ) asyncio . run ( main ())","title":"wait"},{"location":"asyncio/wait/#wait-timeout","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import asyncio import logging logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , datefmt = \"%H:%M:%S\" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def do_work ( delay , work ): await asyncio . sleep ( delay ) return work async def main (): task1 = asyncio . create_task ( do_work ( 1 , \"hello1\" )) task2 = asyncio . create_task ( do_work ( 2 , \"hello2\" )) task3 = asyncio . create_task ( do_work ( 3 , \"hello3\" )) tasks = [ task1 , task2 , task3 ] finished , unfinished = await asyncio . wait ( tasks , timeout = 3 ) for task in finished : log . info ( task . result ()) for task in unfinished : task . cancel () await asyncio . wait ( unfinished ) asyncio . run ( main ()) Result [INFO] 2022-01-08 11:34:43,555 hello2 [INFO] 2022-01-08 11:34:43,555 hello1","title":"wait timeout"},{"location":"asyncio/wait/#wait_for","text":"Wait for the awaitable to complete with a timeout. If timeout raise Task are cancelled wait_for_demo.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import asyncio import logging WORK_TIME = 2 logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , datefmt = \"%H:%M:%S\" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def do_work ( delay : int ): log . info ( f \"start work { delay } \" ) await asyncio . sleep ( delay ) log . info ( f \"end work { delay } \" ) async def main (): task = asyncio . create_task ( do_work ( WORK_TIME )) try : await asyncio . wait_for ( asyncio . shield ( task ), timeout = 1 ) log . info ( \"end success\" ) except asyncio . TimeoutError : log . error ( \"oops Timeout\" ) loop = asyncio . get_event_loop () loop . create_task ( main ()) loop . run_forever () Note Task cancel if time out raise To protect task from cancelling use asyncio.shield Replace line 17 with await asyncio.wait_for(asyncio.shield(task), timeout=1) Without shield [INFO] 09:59:20 start work 2 [ERROR] 09:59:21 oops Timeout With shield [INFO] 10:00:05 start work 2 [ERROR] 10:00:06 oops Timeout [INFO] 10:00:07 end work 2","title":"wait_for"},{"location":"asyncio/wait/#other-examples","text":"Run task multiple time with timeout until complete wait_until_success.py import asyncio import logging import random logging . basicConfig ( format = \"[ %(levelname)s ] %(asctime)s %(message)s \" , datefmt = \"%H:%M:%S\" , level = logging . DEBUG ) log = logging . getLogger ( __name__ ) async def do_work (): delay = random . randint ( 1 , 4 ) log . info ( f \"start work { delay } \" ) await asyncio . sleep ( delay ) log . info ( f \"end work { delay } \" ) async def main (): while True : try : task = asyncio . create_task ( do_work ()) await asyncio . wait_for ( task , timeout = 2 ) log . info ( \"end success\" ) break except asyncio . TimeoutError : log . error ( \"oops Timeout\" ) loop = asyncio . get_event_loop () loop . create_task ( main ()) loop . run_forever ()","title":"Other examples"},{"location":"dataclasses/dc_dict/","text":"Dataclass Dict relations \u00b6 convert DC to Dict and back \u00b6 asdict method: convert D.C to dict unpack: init dataclass with unpack dict into init method acite package : simplifies creation of data classes (PEP 557) from dictionaries. asdict \u00b6 using builtin method from dataclasses import dataclass , asdict @dataclass class Point3D : x : int y : int z : int point_3d = Point3D ( 1 , 2 , 3 ) print ( point_3d ) d_data = asdict ( point_3d ) print ( d_data ) # Result dataclass : Point3D ( x = 1 , y = 2 , z = 3 ) Dict : { 'x' : 1 , 'y' : 2 , 'z' : 3 } unpack \u00b6 from dataclasses import dataclass @dataclass class Point3D : x : int # pylint: disable=invalid-name y : int z : int point_data = { \"x\" : 1 , \"y\" : 2 , \"z\" : 3 } point_3d = Point3D ( ** point_data ) print ( point_data ) print ( point_3d ) # Result Dict : { 'x' : 1 , 'y' : 2 , 'z' : 3 } Dataclass : Point3D ( x = 1 , y = 2 , z = 3 ) dacite \u00b6 package github pip install dacite Demo using nested with optional More examples in github repo from dataclasses import dataclass from typing import Optional from dacite import from_dict @dataclass class A : x : str y : Optional [ int ] @dataclass class B : a : A data = { 'a' : { 'x' : 'test' , 'y' : 1 , } } data_opt = { 'a' : { 'x' : 'test' } } result = from_dict ( data_class = B , data = data ) print ( result ) result = from_dict ( data_class = B , data = data_opt ) print ( result ) # Result B ( a = A ( x = 'test' , y = 1 )) B ( a = A ( x = 'test' , y = None ))","title":"Dataclass Dict relations"},{"location":"dataclasses/dc_dict/#dataclass-dict-relations","text":"","title":"Dataclass Dict relations"},{"location":"dataclasses/dc_dict/#convert-dc-to-dict-and-back","text":"asdict method: convert D.C to dict unpack: init dataclass with unpack dict into init method acite package : simplifies creation of data classes (PEP 557) from dictionaries.","title":"convert DC to Dict and back"},{"location":"dataclasses/dc_dict/#asdict","text":"using builtin method from dataclasses import dataclass , asdict @dataclass class Point3D : x : int y : int z : int point_3d = Point3D ( 1 , 2 , 3 ) print ( point_3d ) d_data = asdict ( point_3d ) print ( d_data ) # Result dataclass : Point3D ( x = 1 , y = 2 , z = 3 ) Dict : { 'x' : 1 , 'y' : 2 , 'z' : 3 }","title":"asdict"},{"location":"dataclasses/dc_dict/#unpack","text":"from dataclasses import dataclass @dataclass class Point3D : x : int # pylint: disable=invalid-name y : int z : int point_data = { \"x\" : 1 , \"y\" : 2 , \"z\" : 3 } point_3d = Point3D ( ** point_data ) print ( point_data ) print ( point_3d ) # Result Dict : { 'x' : 1 , 'y' : 2 , 'z' : 3 } Dataclass : Point3D ( x = 1 , y = 2 , z = 3 )","title":"unpack"},{"location":"dataclasses/dc_dict/#dacite","text":"package github pip install dacite Demo using nested with optional More examples in github repo from dataclasses import dataclass from typing import Optional from dacite import from_dict @dataclass class A : x : str y : Optional [ int ] @dataclass class B : a : A data = { 'a' : { 'x' : 'test' , 'y' : 1 , } } data_opt = { 'a' : { 'x' : 'test' } } result = from_dict ( data_class = B , data = data ) print ( result ) result = from_dict ( data_class = B , data = data_opt ) print ( result ) # Result B ( a = A ( x = 'test' , y = 1 )) B ( a = A ( x = 'test' , y = None ))","title":"dacite"},{"location":"environment/code_better/black_pylint_mypy/","text":"Use black, mypy, pylint and other to code like pro \u00b6 Black \u00b6 Format python code automatically pip install black usage \u00b6 black <file or folder to format> # check only black --check <file or folder to format> VSCode config \u00b6 \"editor.formatOnSave\" : true , \"editor.formatOnPaste\" : true , \"python.formatting.provider\" : \"black\" , ?? \"python.formatting.blackArgs\" : [ \"-t\" , \"py37\" ] mypy \u00b6 Mypy is a static type checker to check python annotations pip install mypy usage \u00b6 mypy <filename>.py pylint \u00b6 Python code analysis pip install pylint VSCode \u00b6 \"python.linting.pylintEnabled\" : true .pylintrc \u00b6 Add .pylintrc to control lint for example: disabled missing docstring [MASTER] disable = C0114, # (missing-module-docstring) C0115 # (missing-class-docstring) control lint in code \u00b6 Disabled on specific line @dataclass class Point3D : x : int # pylint: disable=invalid-name y : int z : int lint still warning invalid-name on y,z variable Tools to check \u00b6 - bandit \u00b6 Reference \u00b6 Use black, mypy, and pylint to make your Python code more professional","title":"Use black, mypy, pylint and other to code like pro"},{"location":"environment/code_better/black_pylint_mypy/#use-black-mypy-pylint-and-other-to-code-like-pro","text":"","title":"Use black, mypy, pylint and other to code like pro"},{"location":"environment/code_better/black_pylint_mypy/#black","text":"Format python code automatically pip install black","title":"Black"},{"location":"environment/code_better/black_pylint_mypy/#usage","text":"black <file or folder to format> # check only black --check <file or folder to format>","title":"usage"},{"location":"environment/code_better/black_pylint_mypy/#vscode-config","text":"\"editor.formatOnSave\" : true , \"editor.formatOnPaste\" : true , \"python.formatting.provider\" : \"black\" , ?? \"python.formatting.blackArgs\" : [ \"-t\" , \"py37\" ]","title":"VSCode config"},{"location":"environment/code_better/black_pylint_mypy/#mypy","text":"Mypy is a static type checker to check python annotations pip install mypy","title":"mypy"},{"location":"environment/code_better/black_pylint_mypy/#usage_1","text":"mypy <filename>.py","title":"usage"},{"location":"environment/code_better/black_pylint_mypy/#pylint","text":"Python code analysis pip install pylint","title":"pylint"},{"location":"environment/code_better/black_pylint_mypy/#vscode","text":"\"python.linting.pylintEnabled\" : true","title":"VSCode"},{"location":"environment/code_better/black_pylint_mypy/#pylintrc","text":"Add .pylintrc to control lint for example: disabled missing docstring [MASTER] disable = C0114, # (missing-module-docstring) C0115 # (missing-class-docstring)","title":".pylintrc"},{"location":"environment/code_better/black_pylint_mypy/#control-lint-in-code","text":"Disabled on specific line @dataclass class Point3D : x : int # pylint: disable=invalid-name y : int z : int lint still warning invalid-name on y,z variable","title":"control lint in code"},{"location":"environment/code_better/black_pylint_mypy/#tools-to-check","text":"","title":"Tools to check"},{"location":"environment/code_better/black_pylint_mypy/#-bandit","text":"","title":"- bandit"},{"location":"environment/code_better/black_pylint_mypy/#reference","text":"Use black, mypy, and pylint to make your Python code more professional","title":"Reference"},{"location":"environment/git/cheat-sheet/","text":"update local list of remote branches \u00b6 git remote update origin --prune Change prompt to show git current branch \u00b6 export PS1=\"\\[\\033[36m\\]\\u\\[\\033[m\\]@\\[\\033[32m\\] \\[\\033[33;1m\\]\\w\\[\\033[m\\] (\\$(git branch 2>/dev/null | grep '^*' | colrm 1 2)) \\$ - \\033[0m : No Color - \\033[36m : Cyan - \\033[33;1m : Yellow - \\u: user - \\w: pwd Note Black 0;30 Dark Gray 1;30 Red 0;31 Light Red 1;31 Green 0;32 Light Green 1;32 Brown/Orange 0;33 Yellow 1;33 Blue 0;34 Light Blue 1;34 Purple 0;35 Light Purple 1;35 Cyan 0;36 Light Cyan 1;36 Light Gray 0;37 White 1;37","title":"GIT cheat sheet"},{"location":"environment/git/cheat-sheet/#update-local-list-of-remote-branches","text":"git remote update origin --prune","title":"update local list of remote branches"},{"location":"environment/git/cheat-sheet/#change-prompt-to-show-git-current-branch","text":"export PS1=\"\\[\\033[36m\\]\\u\\[\\033[m\\]@\\[\\033[32m\\] \\[\\033[33;1m\\]\\w\\[\\033[m\\] (\\$(git branch 2>/dev/null | grep '^*' | colrm 1 2)) \\$ - \\033[0m : No Color - \\033[36m : Cyan - \\033[33;1m : Yellow - \\u: user - \\w: pwd Note Black 0;30 Dark Gray 1;30 Red 0;31 Light Red 1;31 Green 0;32 Light Green 1;32 Brown/Orange 0;33 Yellow 1;33 Blue 0;34 Light Blue 1;34 Purple 0;35 Light Purple 1;35 Cyan 0;36 Light Cyan 1;36 Light Gray 0;37 White 1;37","title":"Change prompt to show git current branch"},{"location":"environment/git/git-hooks/","text":"Git hooks are scripts that Git executes automatically every time particular event occures in a Git repository. Every Git repository has a .git/hooks folder with a script for each hook you can bind to. Client side most common used \u00b6 Hook Name Event Description pre-commit git commit Call before commit exiting with anything other the zero post-merge git merge Call after merge post-checkout git checkout git clone Run hook after updating the worktree or after git clone Tip Add .git folder to VSCode files.exclude\": { \"**/.git\": false } Samples \u00b6 Minimal BASH \u00b6 Place file name pre-commit in .git/hook folder Assign executable permission if script return error (!=0) commit cancel if script return 0 commit allowed #!/bin/bash #!/bin/bash echo -e \"git failed to commit\" exit 1 Minimal Python \u00b6 #!/usr/bin/env python3 print ( \"git failed to commit\" ) exit ( 1 ) Hook demo \u00b6 Implement python script that check if json file can parse using json.tool python model - implement as pre-commit hook python -m json.tool <file name> json file demo.json with error { \"line1\" : 1 , \"line2\" : 2 , } run json.tool python -m json.tool demo.json # Expecting property name enclosed in double quotes: line 4 column 1 ( char 34 ) check json \u00b6 Commit VSCode \u00b6 Warning Don't forget to assign executable permission chmod +x .git/hook/pre-commit References \u00b6 githooks Get Started with Git Hooks Raise the Bar of Code Quality in Python Projects","title":"GIT hooks"},{"location":"environment/git/git-hooks/#client-side-most-common-used","text":"Hook Name Event Description pre-commit git commit Call before commit exiting with anything other the zero post-merge git merge Call after merge post-checkout git checkout git clone Run hook after updating the worktree or after git clone Tip Add .git folder to VSCode files.exclude\": { \"**/.git\": false }","title":"Client side most common used"},{"location":"environment/git/git-hooks/#samples","text":"","title":"Samples"},{"location":"environment/git/git-hooks/#minimal-bash","text":"Place file name pre-commit in .git/hook folder Assign executable permission if script return error (!=0) commit cancel if script return 0 commit allowed #!/bin/bash #!/bin/bash echo -e \"git failed to commit\" exit 1","title":"Minimal BASH"},{"location":"environment/git/git-hooks/#minimal-python","text":"#!/usr/bin/env python3 print ( \"git failed to commit\" ) exit ( 1 )","title":"Minimal Python"},{"location":"environment/git/git-hooks/#hook-demo","text":"Implement python script that check if json file can parse using json.tool python model - implement as pre-commit hook python -m json.tool <file name> json file demo.json with error { \"line1\" : 1 , \"line2\" : 2 , } run json.tool python -m json.tool demo.json # Expecting property name enclosed in double quotes: line 4 column 1 ( char 34 )","title":"Hook demo"},{"location":"environment/git/git-hooks/#check-json","text":"","title":"check json"},{"location":"environment/git/git-hooks/#commit-vscode","text":"Warning Don't forget to assign executable permission chmod +x .git/hook/pre-commit","title":"Commit VSCode"},{"location":"environment/git/git-hooks/#references","text":"githooks Get Started with Git Hooks Raise the Bar of Code Quality in Python Projects","title":"References"},{"location":"environment/pbr/","text":"PBR \u00b6 PBR is a nice little add-on to simplify the setup and the deployment of your packages. References \u00b6 What is python pbr?","title":"pbr"},{"location":"environment/pbr/#pbr","text":"PBR is a nice little add-on to simplify the setup and the deployment of your packages.","title":"PBR"},{"location":"environment/pbr/#references","text":"What is python pbr?","title":"References"},{"location":"environment/pdm/","text":"PDM, a new Python package manager and workflow tool that leverages PEP 582 to get rid of virtualenv entirely. It installs dependencies into the local package directory package and makes Python interpreters aware of it. References \u00b6 You don't really need a virtualenv PEP 582","title":"PDM"},{"location":"environment/pdm/#references","text":"You don't really need a virtualenv PEP 582","title":"References"}]}